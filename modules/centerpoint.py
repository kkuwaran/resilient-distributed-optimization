# -*- coding: utf-8 -*-
"""centerpoint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bFg77IFEp-FN0cWGOJLIX5705XXx6Wy7

### utils
"""

import math
import numpy as np
import random
from shapely.geometry import Point
from shapely.geometry import MultiPoint


def findKthLargest(nums, k):
    '''
    O(n) time to find the k-th largest number in an array
    '''
    pivot = random.choice(nums)
    nums1, nums2 = [], []
    for num in nums:
        if num > pivot:
            nums1.append(num)
        elif num < pivot:
            nums2.append(num)
    if k <= len(nums1):
        return findKthLargest(nums1, k)
    if k > len(nums) - len(nums2):
        return findKthLargest(nums2, k - (len(nums) - len(nums2)))
    return pivot

"""### plot-utils"""

import numpy as np
from matplotlib import pyplot as plt


def prepare_plot(point_set):
    plt.ion()
    plt.show()
    plt.title('Points')
    x_min, x_max = find_x_bounds(point_set)
    interval = Interval(x_min - 10, x_max + 10)
    y_min, y_max = find_y_bounds(point_set)
    prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
    plot_point_set(point_set)
    plt.pause(1)


def find_x_bounds(point_set):
    min_x = min(point_set, key=lambda P: P.x).x
    max_x = max(point_set, key=lambda P: P.x).x
    return min_x, max_x


def find_y_bounds(point_set):
    min_y = min(point_set, key=lambda P: P.y).y
    max_y = max(point_set, key=lambda P: P.y).y
    return min_y, max_y


class Interval:
    def __init__(self, l, r):
        self.l = l
        self.r = r
        assert l <= r

    def __str__(self):
        return 'Interval from {} to {}'.format(self.l, self.r)

    def __len__(self):
        return int(self.r - self.l)


def prepare_axis(min_x=-10, max_x=10, min_y=-10, max_y=10):
    plt.grid(True, which='major')
    ax = plt.gca()
    min_x = int(min_x)
    max_x = int(max_x)
    min_y = int(min_y)
    max_y = int(max_y)
    ax.set_xlim(min_x, max_x)
    ax.set_ylim(min_y, max_y)
    plt.xticks(np.arange(min(np.array(ax.get_xlim())), max(np.array(ax.get_xlim())) + 1, int((max_x-min_x)/10)))
    plt.yticks(np.arange(min(np.array(ax.get_ylim())), max(np.array(ax.get_ylim())) + 1, int((max_y-min_y)/10)))
    plt.gca().set_aspect('equal', adjustable='box')
    plt.axhline(0, color='black')
    plt.axvline(0, color='black')


def plot_line(L, linestyle='--', color='b'):
    axes = plt.gca()
    x_vals = np.array(axes.get_xlim())
    y_vals = L.b + L.m * x_vals
    plt.plot(x_vals, y_vals, ls=linestyle, color=color)
    plt.draw()


def plot_vertical_line(x, linestyle=':', color='g', linewidth=5):
    plt.axvline(x=x, ls=linestyle, color=color, linewidth=linewidth)


def plot_line_segment(L, linestyle='-', color='b'):
    plt.plot([L.p1.x, L.p2.x], [L.p1.y, L.p2.y], ls=linestyle, color=color, linewidth=4)


def plot_point(P, marker='o', color='b', size=4):
    plt.plot(P.x, P.y, marker=marker, color=color, markersize=size, markeredgecolor='k', markeredgewidth=0.1)
    plt.draw()


def plot_points_and_duals(red_points, blue_points, red_duals, blue_duals, t=0.5):
    for p, d in zip(red_points, red_duals):
        plot_point(p, color='r')
        plt.draw()
        # plt.pause(t)
        plot_line(d, color='r')
        plt.draw()
        # plt.pause(t)
    for p, d in zip(blue_points, blue_duals):
        plot_point(p, color='b')
        plt.draw()
        # plt.pause(t)
        plot_line(d, color='b')
        plt.draw()
        # plt.pause(t)


def plot_point_set(point_set, color='b'):
    for p in point_set:
        plot_point(p, color=color)


def plot_interval(I, linestyle=':', color='g'):
    plot_vertical_line(I.l, linestyle=linestyle, color=color, linewidth=2)
    plot_vertical_line(I.r, linestyle=linestyle, color=color, linewidth=2)

"""### geo-utils"""

import math
import numpy as np
import random
from shapely.geometry import Point
from shapely.geometry import MultiPoint
from shapely.geometry import LineString

# from centerpoint.utils.PlotUtils import *
# from centerpoint.utils.utils import *

class Line:
    def __init__(self, m, b):
        self.m = m
        self.b = b


class LineSegment:
    def __init__(self, point1, point2):
        self.p1 = point1
        self.p2 = point2

    def __str__(self):
        return 'LineSegment ({}, {})'.format(self.p1, self.p2)


class Interval:
    def __init__(self, l, r):
        self.l = l
        self.r = r
        assert l <= r

    def __str__(self):
        return 'Interval from {} to {}'.format(self.l, self.r)

    def __len__(self):
        return int(self.r - self.l)


class Intersection:
    def __init__(self, line1, line2):
        if line1.m == line2.m:
            self.x = np.inf
            self.y = np.inf
        else:
            self.x = (line2.b - line1.b) / (line1.m - line2.m)
            self.y = line1.m * self.x + line1.b




def remove_repeat_points(point_set):
    points = [(p.x, p.y) for p in point_set if not p.x == np.inf and not p.y == np.inf]
    points = list(set(points))
    point_set = [Point(p[0], p[1]) for p in points]

    return point_set


def find_corner_points(point_set):
    convex_hull = MultiPoint(point_set).convex_hull
    corner_points = [p for p in point_set if not p.within(convex_hull)]
    return corner_points


def line_over_two_points(p1, p2):
    if p1.x == p2.x:
        return Line(np.inf, 0)
    else:
        k = (p2.y - p1.y) / (p2.x - p1.x)
        b = -p1.x * ((p2.y - p1.y) / (p2.x - p1.x)) + p1.y
    return Line(k, b)


def find_x_bounds(point_set):
    min_x = min(point_set, key=lambda P: P.x).x
    max_x = max(point_set, key=lambda P: P.x).x
    return min_x, max_x


def find_y_bounds(point_set):
    min_y = min(point_set, key=lambda P: P.y).y
    max_y = max(point_set, key=lambda P: P.y).y
    return min_y, max_y


def compute_dual_line(P):
    """Compute dual of a point
    Arguments:
        P {shapely.geometry.Point}
    """
    return Line(P.x, -P.y)


def random_point_set(n, lower=-10, upper=10):
    points = []
    assert lower <= upper
    for i in range(n):
        x = random.uniform(lower, upper)
        y = random.uniform(lower, upper)
        points.append(Point(x, y))
    return points


def get_Radon_point(p1, p2, p3, p4):
    point_set = [p1,p2,p3,p4]
    convex_hull = MultiPoint([p1,p2,p3,p4]).convex_hull
    if p1.within(convex_hull):
        return p1
    elif p2.within(convex_hull):
        return p2
    elif p3.within(convex_hull):
        return p3
    elif p4.within(convex_hull):
        return p4
    else:
        for a, b in zip([(p1,p3),(p1,p2),(p1,p4)], [(p2,p4),(p3,p4),(p2,p3)]):
            line1 = line_over_two_points(a[0],a[1])
            line2 = line_over_two_points(b[0],b[1])
            Radon_point = Point(Intersection(line1, line2).x,Intersection(line1, line2).y)
            if Radon_point.within(convex_hull):
                return Radon_point
        X = [p.x for p in point_set]
        med_x = findKthLargest(X, 2)
        index = X.index(med_x)
        return Point(point_set[index].x, point_set[index].y)



def point_transfer(p, x0, y0, line):
    x = p.x
    y = p.y
    k = line.m
    b = line.b
    sin_angle = -1 / (math.sqrt(k ** 2 + 1)) if k > 0 else 1 / (math.sqrt(k ** 2 + 1))
    cos_angle = k / (math.sqrt(k ** 2 + 1)) if k > 0 else -k / (math.sqrt(k ** 2 + 1))
    x_prime = (x - x0) * cos_angle + (y - y0) * sin_angle
    y_prime = (y - y0) * cos_angle - (x - x0) * sin_angle
    return Point(x_prime, y_prime)


def point_transfer_back(p_prime, x0, y0, line):
    x_prime = p_prime.x
    y_prime = p_prime.y
    k = line.m
    b = line.b
    sin_angle = -1 / (math.sqrt(k ** 2 + 1)) if k > 0 else 1 / (math.sqrt(k ** 2 + 1))
    cos_angle = k / (math.sqrt(k ** 2 + 1)) if k > 0 else -k / (math.sqrt(k ** 2 + 1))
    x = x_prime * cos_angle - y_prime * sin_angle + x0
    y = y_prime * cos_angle + x_prime * sin_angle + y0
    return Point(x, y)


def test_point_transfer():
    '''
    if point transfer and transfer back functions are correct,
    the black and red points should overlap.
    '''
    k = 0.1
    b = 0
    l = Line(k, b)
    x0 = 2
    y0 = k * x0 + b
    coord = Point(x0, y0)
    l_pend = Line(-1 / k, 1 / k * coord.x + coord.y)

    sin_angle = -1 / (math.sqrt(k ** 2 + 1)) if k > 0 else 1 / (math.sqrt(k ** 2 + 1))
    cos_angle = k / (math.sqrt(k ** 2 + 1)) if k > 0 else -k / (math.sqrt(k ** 2 + 1))

    plt.ion()
    plt.show()
    prepare_axis()
    plot_line(l)
    plot_line(l_pend)

    point_set = random_point_set(10, lower=-10, upper=10)
    plot_point_set(point_set, color='k')
    P = []
    P_trans = []

    for p in point_set:
        p_trans = point_transfer(p, x0, y0, l)
        P_trans.append(p_trans)
        p_trans_back = point_transfer_back(p_trans, x0, y0, l)
        P.append(p_trans_back)

    # plot_point_set(P_trans, color='b')
    plot_point_set(P, color='r')

    plt.pause(1)
    # end = input('Press enter to end the next step')


if __name__ == '__main__':
    test_point_transfer()

"""### hamcut"""

# from centerpoint.utils.GeoUtils import *
# from centerpoint.utils.PlotUtils import *
# from centerpoint.utils.utils import *


class HamCut:
    def __init__(self):
        self.red_points = None
        self.blue_points = None
        self.red_num = None
        self.blue_num = None

        # all points
        self.all_points = None

        # red duals are with negative slope and blue duals are with positive slope
        self.red_duals = None
        self.blue_duals = None
        self.remaining_blue_duals = None

        self.num_need_red = None
        self.num_need_blue = None
        self.above = True

        self.ham_cut = None
        self.ham_point = None

        self.plot = None

    def reduce_then_cut(self, red_points, blue_points, num_need_red, num_need_blue, above=True, plot=False):
        self.red_points = red_points
        self.blue_points = blue_points
        self.all_points = self.red_points + self.blue_points
        self.red_num = len(self.red_points)
        self.blue_num = len(self.blue_points)
        self.above = above
        if self.above == True:
            self.num_need_red = num_need_red
            self.num_need_blue = num_need_blue
        else:
            self.num_need_red = self.red_num - 1 - num_need_red
            self.num_need_blue = self.blue_num - 1 - num_need_blue
        self.plot = plot

        # red duals are with negative slope and blue duals are with positive slope
        self.red_duals = [compute_dual_line(p) for p in self.red_points]
        self.blue_duals = [compute_dual_line(p) for p in self.blue_points]
        self.remaining_blue_duals = self.blue_duals

        query_positive_line = random.choice(self.blue_duals)
        if self.plot:
            prepare_plot(self.all_points)
            plot_points_and_duals(self.red_points, self.blue_points, self.red_duals, self.blue_duals, t=0.5)
            plt.pause(1)
            # end = input('Press enter to the next step.')
            plt.clf()
            x_min, x_max = find_x_bounds(self.all_points)
            interval = Interval(x_min - 10, x_max + 10)
            y_min, y_max = find_y_bounds(self.all_points)
            prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
            for r in self.red_duals:
                plot_line(r, color='r')
            plot_line(query_positive_line, color='b')
            plt.pause(1)
            # end = input('Press enter to the next step.')

        return self.query_line(query_positive_line)

    def query_line(self, query_line):
        intersections_with_query_line = [Intersection(red_dual, query_line) for red_dual in
                                         self.red_duals]
        kth_intersection_x = findKthLargest([inter.x for inter in intersections_with_query_line],
                                            self.red_num + 1 - self.num_need_red - 1)
        kth_intersection_y = intersections_with_query_line[
            [inter.x for inter in intersections_with_query_line].index(kth_intersection_x)].y
        if self.plot:
            plt.clf()
            plt.title('Find kth intersection')
            x_min, x_max = find_x_bounds(self.all_points)
            interval = Interval(x_min - 10, x_max + 10)
            y_min, y_max = find_y_bounds(self.all_points)
            prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
            for r in self.red_duals:
                plot_line(r, color='r')
            plot_line(query_line, color='b')
            plot_point(Point(kth_intersection_x, kth_intersection_y), color='g')
            plt.pause(1)
            # end = input('Press enter to the next step.')

        positive_duals_below_point = [l for l in self.blue_duals if
                                      kth_intersection_y > l.m * kth_intersection_x + l.b and not l == query_line]
        if self.plot:
            plt.title('Blue duals below intersection')
            for b in positive_duals_below_point:
                plot_line(b, color='b')
            plt.pause(1)
            # end = input('Press enter to the next step.')

        if len(positive_duals_below_point) == self.num_need_blue:
            self.ham_point = Point(kth_intersection_x, kth_intersection_y)
            self.ham_cut = compute_dual_line(self.ham_point)
            if self.plot:
                plt.clf()
                x_min, x_max = find_x_bounds(self.all_points)
                interval = Interval(x_min - 10, x_max + 10)
                y_min, y_max = find_y_bounds(self.all_points)
                prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
                plot_point_set(self.red_points, color='r')
                plot_point_set(self.blue_points, color='b')
                plot_line(self.ham_cut, color='g')
                plt.pause(1)
                # end = input('Press enter to the next step.')
            return self.ham_cut
        elif len(positive_duals_below_point) > self.num_need_blue:
            self.remaining_blue_duals = [l for l in self.remaining_blue_duals if l in positive_duals_below_point]
            if len(self.remaining_blue_duals) == 1:
                return self.query_line(self.remaining_blue_duals[0])
            else:
                y_vals = [l.m * kth_intersection_x + l.b for l in self.remaining_blue_duals]
                y_vals_med = findKthLargest(y_vals, math.floor(len(y_vals) / 2))
                dual_med = self.remaining_blue_duals[y_vals.index(y_vals_med)]
                return self.query_line(dual_med)
        else:
            self.remaining_blue_duals = [l for l in self.remaining_blue_duals if
                                         l not in positive_duals_below_point and not l == query_line]
            if len(self.remaining_blue_duals) == 1:
                return self.query_line(self.remaining_blue_duals[0])
            else:
                y_vals = [l.m * kth_intersection_x + l.b for l in self.remaining_blue_duals]
                y_vals_med = findKthLargest(y_vals, math.floor(len(y_vals) / 2))
                dual_med = self.remaining_blue_duals[y_vals.index(y_vals_med)]
                return self.query_line(dual_med)


# if __name__ == '__main__':
#     random.seed(1)
#     n_red = 100  # default 5000
#     n_blue = 100  # default 5000
#     red_points = []
#     blue_points = []
#     num_need_red = int(n_red / 12)
#     num_need_blue = int(n_blue / 4)
#     above = True
#     plot = False
#     for i in range(n_red):
#         x = random.uniform(-5, 0)
#         y = random.uniform(-5, 5)
#         red_points.append(Point(x, y))
#     for i in range(n_blue):
#         x = random.uniform(0, 5)
#         y = random.uniform(-5, 5)
#         blue_points.append(Point(x, y))

#     hamcut = HamCut()
#     cut = hamcut.reduce_then_cut(red_points, blue_points, num_need_red, num_need_blue, above=above, plot=plot)
#     print(cut.m, cut.b)

#     plt.clf()
#     x_min, x_max = find_x_bounds(hamcut.all_points)
#     interval = Interval(x_min - 10, x_max + 10)
#     y_min, y_max = find_y_bounds(hamcut.all_points)
#     prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
#     plot_point_set(hamcut.red_points, color='r')
#     plot_point_set(hamcut.blue_points, color='b')
#     plot_line(hamcut.ham_cut, color='g')
#     plt.pause(1)
#     # end = input('Press enter to the next step.')

"""### centerpoint"""

from copy import deepcopy
from shapely.geometry import Polygon
# from centerpoint.HamCut.HamCut import *
# from centerpoint.utils.GeoUtils import *
# from centerpoint.utils.utils import *
import itertools
import random

class Centerpoint:
    def __init__(self, plot=False):
        self.point_set = None

        self.points_in_L = None
        self.points_not_in_L = None
        self.points_in_L_boundary = None

        self.points_in_U = None
        self.points_not_in_U = None
        self.points_in_D_boundary = None

        self.points_in_D = None
        self.points_not_in_D = None

        self.L_boundary_line = None
        self.U_boundary_line = None
        self.D_boundary_line = None
        self.R_boundary_line = None

        self.points_LU = None
        self.points_LD = None
        self.points_RU = None
        self.points_RD = None

        self.plot = plot

    def initialize(self, point_set):
        self.point_set = point_set
        self.n = len(self.point_set)
        self.np = math.ceil(self.n / 3)
        self.mp = math.ceil(self.n / 3) - math.ceil(self.n / 4)
        self.x_min, self.x_max = find_x_bounds(self.point_set)
        self.y_min, self.y_max = find_y_bounds(self.point_set)

    def getSafeCenterPoint(self, point_set):
        cp = []

        # determine if points are in the same line, if so, add small noise
        # point_set = set([(p.x, p.y) for p in self.point_set])
        self.point_set = deepcopy(point_set)
        leftmost = Point(min(self.point_set, key=lambda P: P.x).x, min(self.point_set, key=lambda P: P.x).y)
        rightmost = Point(max(self.point_set, key=lambda P: P.x).x, max(self.point_set, key=lambda P: P.x).y)
        l = LineString([leftmost, rightmost])
        oneLine = True
        for p in self.point_set:
            if p not in [leftmost, rightmost]:
                contain = l.contains(p)
                oneLine = oneLine and contain
        if oneLine:
            point_set = [Point(p.x+0.0001*random.random(), p.y+0.0001*random.random()) for p in point_set]

        for d in range(0, 3):
            self.point_set = deepcopy(point_set)
            l = Line(0.1 * (d+1), 0)
            p_trans = [point_transfer(p, 0, 0, l) for p in self.point_set]
            try:
                cp_trans = self.reduce_then_get_centerpoint(p_trans)
                cp_trans_back = point_transfer_back(cp_trans, 0, 0, l)
                cp.append(cp_trans_back)
            except:
                pass

        try:
            safe_point = Polygon([[p.x, p.y] for p in cp]).centroid
        except:
            try:
                safe_point = LineString([p for p in cp]).centroid
            except:
                safe_point = cp[0]

        return safe_point



    def reduce_then_get_centerpoint(self, point_set):
        point_set = [Point(p.x + 0.0001 * random.random(), p.y + 0.0001 * random.random()) for p in point_set]
        self.point_set = point_set
        last_point_num = len(self.point_set)
        cur_point_num = 0
        #print("point number: %d" % last_point_num)
        while cur_point_num < last_point_num:
            last_point_num = len(self.point_set)
            self.initialize(self.point_set)
            try:
                self.find_L_boundary()
                self.find_U_boundary()
                self.find_D_boundary()
                self.find_R_boundary()
                self.find_intersections()
                self.replace_points()
                # self.point_set = remove_repeat_points(self.point_set)
                cur_point_num = len(self.point_set)
                #print("point number: %d" % cur_point_num)
            except:
               pass
            cur_point_num = len(self.point_set)
        # return self.brute_force_centerpoint_old(self.point_set)
        return self.brute_force_centerpoint(self.point_set)


    def brute_force_centerpoint(self, point_set):
        # self.point_set = remove_repeat_points(self.point_set)

        point_set = [Point(p.x + 0.0001 * random.random(), p.y + 0.0001 * random.random()) for p in point_set]
        while len(point_set) > 10:
            p_corner = find_corner_points(point_set)[0:4]
            if len(p_corner) == 1:
                return p_corner
            for p in p_corner:
                point_set.remove(p)
            if len(p_corner) == 4:
                Radon_point = get_Radon_point(p_corner[0], p_corner[1], p_corner[2], p_corner[3])
                point_set.append(Radon_point)

        remaining_points = deepcopy(point_set)

        n = len(point_set)
        f = math.ceil(n/3) - 1
        # for i in range(nCr(n, n-f)):
        empty_inter = True
        iter_set = list(itertools.combinations(point_set, n-f))
        random.shuffle(iter_set)
        for point_set in iter_set:
            if empty_inter:
                inter = Polygon([p for p in point_set]).convex_hull
                # inter = inter.buffer(0)
                empty_inter = False
            else:
                polygon = Polygon([p for p in point_set]).convex_hull
                # polygon = polygon.buffer(0)
                inter = polygon.intersection(inter)
                if inter.geom_type == 'Point':
                    break
        cp = inter.centroid
        #for cp in centerpoints:
        #    print("Centerpoints: %.2f, %.2f" % (cp.x, cp.y))
        if self.plot:
            plt.clf()
            x_min, x_max = find_x_bounds(point_set)
            interval = Interval(x_min - 10, x_max + 10)
            y_min, y_max = find_y_bounds(point_set)
            prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
            plot_point_set(remaining_points, color='b')
            plt.title('Centerpoint: %.2f, %.2f' % (cp.x, cp.y))
            # plot_point_set(remaining_points, color='b')
            plot_point(cp, color='r')
            plt.pause(1)
            # end = input('Press enter to the next step')
        return cp

    def brute_force_centerpoint_old(self, point_set):
        centerpoints = []
        self.point_set = remove_repeat_points(self.point_set)
        remaining_points = deepcopy(self.point_set)

        while len(self.point_set) > 6:
            p_corner = find_corner_points(self.point_set)[0:4]
            if len(p_corner) == 1:
                return p_corner
            for p in p_corner:
                self.point_set.remove(p)
            if len(p_corner) == 4:
                Radon_point = get_Radon_point(p_corner[0], p_corner[1], p_corner[2], p_corner[3])
                self.point_set.append(Radon_point)

        # get r = math.ceil(n/3) Tverberg point for <= 6 points
        p_set = set([(p.x, p.y) for p in self.point_set])
        p_size = len(self.point_set)
        if p_size == 1:
            centerpoints.append(self.point_set[0])
        elif p_size <= 3:
            centerpoints.append(LineString([p for p in self.point_set]).centroid)
        elif p_size == 4:
            c = MultiPoint(self.point_set).convex_hull
            inside_points = [p for p in self.point_set if p.within(c)]
            if inside_points == []:
                centerpoints.append(
                    get_Radon_point(self.point_set[0], self.point_set[1], self.point_set[2], self.point_set[3]))
            else:
                centerpoints.append(inside_points[0])

        else:
            for i in range(0, p_size):
                for j in (j for j in range(0, p_size) if j > i):
                    for k in (k for k in range(0, p_size) if k > j):
                        subset1 = set([(p.x, p.y) for p in [self.point_set[i], self.point_set[j], self.point_set[k]]])
                        subset2 = p_set.difference(subset1)
                        try:
                            p1 = Polygon([p for p in subset1])
                        except:
                            try:
                                p1 = LineString([p for p in subset1])
                            except:
                                p1 = Point([p for p in subset1])
                        try:
                            p2 = Polygon([p for p in subset2])
                        except:
                            try:
                                p2 = LineString([p for p in subset2])
                            except:
                                p2 = Point([p for p in subset2])

                        inter = p1.intersection(p2)
                        if not inter.is_empty:
                            cp = inter.centroid
                            centerpoints.append(cp)
                            break
                    else:
                        continue
                    break
                else:
                    continue
                break

        #for cp in centerpoints:
        #    print("Centerpoints: %.2f, %.2f" % (cp.x, cp.y))
        if self.plot:
            plt.clf()
            x_min, x_max = find_x_bounds(self.point_set)
            interval = Interval(x_min - 10, x_max + 10)
            y_min, y_max = find_y_bounds(self.point_set)
            prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
            plot_point_set(remaining_points, color='b')
            plt.title('Centerpoint: %.2f, %.2f' % (centerpoints[0].x, centerpoints[0].y))
            # plot_point_set(remaining_points, color='b')
            plot_point(centerpoints[0], color='r')
            plt.pause(1)
            # end = input('Press enter to the next step')
        if len(centerpoints) == 0:
            return
        return centerpoints[0]

    def find_L_boundary(self):
        leftmost_x = min(self.point_set, key=lambda P: P.x).x
        leftmost_y = min(self.point_set, key=lambda P: P.x).y
        leftmost = Point(leftmost_x, leftmost_y)

        slope = [(p.y - leftmost.y) / (p.x - leftmost.x) for p in self.point_set if
                 not (p == leftmost or p.x == leftmost.x)]

        equal_x_num = len([p for p in self.point_set if (p.x == leftmost.x and p.y > leftmost.y)])

        slope_np = findKthLargest(slope, self.np - 1 - equal_x_num)
        slope_np_index = slope.index(slope_np)

        index_before_num = len([p for p in self.point_set if
                                (p.x == leftmost.x and p.y >= leftmost.y and self.point_set.index(
                                    p) <= slope_np_index)])
        L_boundary_point = self.point_set[slope_np_index + index_before_num]

        self.L_boundary_line = Line((L_boundary_point.y - leftmost.y) / (L_boundary_point.x - leftmost.x),
                                    (leftmost.y * L_boundary_point.x - leftmost.x * L_boundary_point.y) / (
                                            L_boundary_point.x - leftmost.x))
        self.points_in_L = [p for p in self.point_set if
                            p.y > p.x * self.L_boundary_line.m + self.L_boundary_line.b + 1e-5]
        self.points_not_in_L = [p for p in self.point_set if
                                p.y < p.x * self.L_boundary_line.m + self.L_boundary_line.b - 1e-5]
        self.points_in_L_boundary = [p for p in self.point_set if
                                     (p.y <= p.x * self.L_boundary_line.m + self.L_boundary_line.b + 1e-5 and
                                      p.y >= p.x * self.L_boundary_line.m + self.L_boundary_line.b - 1e-5)]
        if self.plot:
            plt.clf()
            prepare_plot(self.point_set)
            plt.title('Find L boundary')
            plot_point(leftmost, color='r')
            plot_line(self.L_boundary_line, color='g')
            plot_point_set(self.points_in_L, color='r')
            plot_point_set(self.points_not_in_L, color='b')
            plot_point_set(self.points_in_L_boundary, color='g')
            plt.pause(1)
            # end = input('Press enter to the next step')

    def find_U_boundary(self):
        x0, y0 = self.points_in_L_boundary[0].x, self.points_in_L_boundary[0].y
        points_in_L_trans = [point_transfer(p, x0, y0, self.L_boundary_line) for p in self.points_in_L]
        points_not_in_L_trans = [point_transfer(p, x0, y0, self.L_boundary_line) for p in self.points_not_in_L]
        if not points_in_L_trans == [] and not points_not_in_L_trans == []:
            above = True if self.L_boundary_line.m >= 0 else False
            (red_points, blue_points) = (points_in_L_trans, points_not_in_L_trans) if points_in_L_trans[0].x < \
                                                                                      points_not_in_L_trans[0].x \
                else (points_not_in_L_trans, points_in_L_trans)
            (red_num_need, blue_num_need) = (
                self.mp - 1, self.np - self.mp - 1) if red_points == points_in_L_trans else (
                self.np - self.mp - 1, self.mp - 1)

            hamcut = HamCut()
            ham_cut_trans = hamcut.reduce_then_cut(red_points, blue_points, red_num_need, blue_num_need, above=above)
            ham_points_trans = [Point(self.x_min - 5, (self.x_min - 5) * ham_cut_trans.m + ham_cut_trans.b),
                                Point(self.x_max + 5, (self.x_max + 5) * ham_cut_trans.m + ham_cut_trans.b)]

            ham_points = [point_transfer_back(p, x0, y0, self.L_boundary_line) for p in ham_points_trans]

            self.U_boundary_line = line_over_two_points(ham_points[0], ham_points[1])

            self.points_in_U = [p for p in self.point_set if
                                p.y > p.x * self.U_boundary_line.m + self.U_boundary_line.b + 1e-5]
            self.points_not_in_U = [p for p in self.point_set if
                                    p.y < p.x * self.U_boundary_line.m + self.U_boundary_line.b - 1e-5]
            if len(self.points_in_U) > len(self.points_not_in_U):
                self.points_in_U, self.points_not_in_U = self.points_not_in_U, self.points_in_U

            self.points_in_U_boundary = [p for p in self.point_set if
                                         (p.y <= p.x * self.U_boundary_line.m + self.U_boundary_line.b + 1e-5 and
                                          p.y >= p.x * self.U_boundary_line.m + self.U_boundary_line.b - 1e-5)]
            if self.plot:
                plt.title('Find U boundary')
                plot_line(self.U_boundary_line, color='k')
                plot_point_set(self.points_in_U, color='r')
                plot_point_set(self.points_not_in_U, color='b')
                plot_point_set(self.points_in_U_boundary, color='g')
                plt.pause(1)
                # end = input('Press enter to the next step')

    def find_D_boundary(self):
        x0, y0 = self.points_in_L_boundary[0].x, self.points_in_L_boundary[0].y
        points_in_L_trans = [point_transfer(p, x0, y0, self.L_boundary_line) for p in self.points_in_L]
        points_not_in_L_trans = [point_transfer(p, x0, y0, self.L_boundary_line) for p in self.points_not_in_L]
        if not points_in_L_trans == [] and not points_not_in_L_trans == []:
            above = False if self.L_boundary_line.m >= 0 else True
            (red_points, blue_points) = (points_in_L_trans, points_not_in_L_trans) if points_in_L_trans[0].x < \
                                                                                      points_not_in_L_trans[0].x \
                else (points_not_in_L_trans, points_in_L_trans)
            (red_num_need, blue_num_need) = (
                self.mp - 1, self.np - self.mp - 1) if red_points == points_in_L_trans else (
                self.np - self.mp - 1, self.mp - 1)

            hamcut = HamCut()
            ham_cut_trans = hamcut.reduce_then_cut(red_points, blue_points, red_num_need, blue_num_need, above=above)

            ham_points_trans = [Point(self.x_min - 5, (self.x_min - 5) * ham_cut_trans.m + ham_cut_trans.b),
                                Point(self.x_max + 5, (self.x_max + 5) * ham_cut_trans.m + ham_cut_trans.b)]

            ham_points = [point_transfer_back(p, x0, y0, self.L_boundary_line) for p in ham_points_trans]

            self.D_boundary_line = line_over_two_points(ham_points[0], ham_points[1])

            # slope_reverse = 1 if y0 > x0 * self.D_boundary_line.m + self.D_boundary_line.b + 1e-5 else -1
            self.points_in_D = [p for p in self.point_set if
                                p.y > p.x * self.D_boundary_line.m + self.D_boundary_line.b + 1e-5]
            self.points_not_in_D = [p for p in self.point_set if
                                    p.y < p.x * self.D_boundary_line.m + self.D_boundary_line.b - 1e-5]
            if len(self.points_in_D) > len(self.points_not_in_D):
                self.points_in_D, self.points_not_in_D = self.points_not_in_D, self.points_in_D
            points_in_D_boundary = [p for p in self.point_set if
                                    (p.y <= p.x * self.D_boundary_line.m + self.D_boundary_line.b + 1e-5 and
                                     p.y >= p.x * self.D_boundary_line.m + self.D_boundary_line.b - 1e-5)]
            if self.plot:
                plt.title('Find D boundary')
                plot_line(self.U_boundary_line, color='g')
                plot_line(self.D_boundary_line, color='k')
                plot_point_set(self.points_in_D, color='r')
                plot_point_set(self.points_not_in_D, color='b')
                plot_point_set(points_in_D_boundary, color='g')
                plt.pause(1)
                # end = input('Press enter to the next step')

    def find_R_boundary(self):
        x0, y0 = self.points_in_U_boundary[0].x, self.points_in_U_boundary[0].y
        points_in_U_trans = [point_transfer(p, x0, y0, self.U_boundary_line) for p in self.points_in_U]
        points_not_in_U_trans = [point_transfer(p, x0, y0, self.U_boundary_line) for p in self.points_not_in_U]

        # above = True if self.U_boundary_line.m < 0 else False
        if not points_in_U_trans == [] and not points_not_in_U_trans == []:
            (red_points, blue_points) = (points_in_U_trans, points_not_in_U_trans) if points_in_U_trans[0].x < \
                                                                                      points_not_in_U_trans[0].x \
                else (points_not_in_U_trans, points_in_U_trans)
            (red_num_need, blue_num_need) = (
                self.mp - 1, self.np - self.mp - 1) if red_points == points_in_U_trans else (
                self.np - self.mp - 1, self.mp - 1)

            hamcut = HamCut()
            ham_cut_trans = hamcut.reduce_then_cut(red_points, blue_points, red_num_need, blue_num_need, above=False)

            ham_points_trans = [Point(self.x_min - 5, (self.x_min - 5) * ham_cut_trans.m + ham_cut_trans.b),
                                Point(self.x_max + 5, (self.x_max + 5) * ham_cut_trans.m + ham_cut_trans.b)]

            ham_points = [point_transfer_back(p, x0, y0, self.U_boundary_line) for p in ham_points_trans]

            self.R_boundary_line = line_over_two_points(ham_points[0], ham_points[1])
            self.points_in_R = [p for p in self.point_set if
                                p.y > p.x * self.R_boundary_line.m + self.R_boundary_line.b + 1e-5]
            self.points_not_in_R = [p for p in self.point_set if
                                    p.y < p.x * self.R_boundary_line.m + self.R_boundary_line.b - 1e-5]
            if len(self.points_in_R) > len(self.points_not_in_R):
                self.points_in_R, self.points_not_in_R = self.points_not_in_R, self.points_in_R

            points_in_R_boundary = [p for p in self.point_set if
                                    (p.y <= p.x * self.R_boundary_line.m + self.R_boundary_line.b + 1e-5 and
                                     p.y >= p.x * self.R_boundary_line.m + self.R_boundary_line.b - 1e-5)]
            if self.plot:
                plt.title('Find R boundary')
                plot_line(self.U_boundary_line, color='g')
                plot_line(self.D_boundary_line, color='g')
                plot_line(self.R_boundary_line, color='k')
                plot_point_set(self.points_in_R, color='r')
                plot_point_set(self.points_not_in_R, color='b')
                plot_point_set(points_in_R_boundary, color='g')
                plt.pause(1)
                # end = input('Press enter to the next step')

    def find_intersections(self):
        set_L = set([(p.x, p.y) for p in self.points_in_L])
        set_U = set([(p.x, p.y) for p in self.points_in_U])
        set_R = set([(p.x, p.y) for p in self.points_in_R])
        set_D = set([(p.x, p.y) for p in self.points_in_D])
        set_all_points = set([(p.x, p.y) for p in self.point_set])
        set_LU = set_L.intersection(set_U)
        set_LD = set_L.intersection(set_D)
        set_RU = set_R.intersection(set_U)
        set_RD = set_R.intersection(set_D)
        set_points_in_intersection = set_LU.union(set_LD).union(set_RU).union(set_RD)
        set_points_not_in_intersection = set_all_points.difference(set_points_in_intersection)
        self.points_LU = [Point(p[0], p[1]) for p in list(set_LU)]
        self.points_LD = [Point(p[0], p[1]) for p in list(set_LD)]
        self.points_RU = [Point(p[0], p[1]) for p in list(set_RU)]
        self.points_RD = [Point(p[0], p[1]) for p in list(set_RD)]
        self.points_not_in_intersection = [Point(p[0], p[1]) for p in list(set_points_not_in_intersection)]

        if self.plot:
            plt.title('Find P_LU, P_LD, P_RU, P_RD')
            plot_point_set(self.point_set, color='b')
            plot_point_set(self.points_LU, color='r')
            plot_point_set(self.points_LD, color='g')
            plot_point_set(self.points_RU, color='m')
            plot_point_set(self.points_RD, color='k')
            plt.pause(1)
            # end = input('Press enter to the next step')

    def replace_points(self):
        Radon_point_set = []
        while self.points_LU != [] and self.points_LD != [] and self.points_RU != [] and self.points_RD != []:
            p_LU, p_LD, p_RU, p_RD = self.points_LU.pop(), self.points_LD.pop(), self.points_RU.pop(), self.points_RD.pop()
            Radon_point = get_Radon_point(p_LU, p_RU, p_RD, p_LD)
            Radon_point_set.append(Radon_point)
            if not math.isnan(Radon_point.x) and not math.isnan(Radon_point.y):
                self.points_not_in_intersection.append(Radon_point)

        set_LU = set([(p.x, p.y) for p in self.points_LU])
        set_LD = set([(p.x, p.y) for p in self.points_LD])
        set_RU = set([(p.x, p.y) for p in self.points_RU])
        set_RD = set([(p.x, p.y) for p in self.points_RD])
        set_points_not_in_intersection = set([(p.x, p.y) for p in self.points_not_in_intersection])
        set_all_points = set_points_not_in_intersection.union(set_LU).union(set_LD).union(set_RU).union(set_RD)
        self.point_set = [Point(p[0], p[1]) for p in list(set_all_points)]

        if self.plot:
            plt.clf()
            prepare_plot(self.point_set)
            plt.title('replace Q by their Radon point')
            plot_line(self.L_boundary_line, color='g')
            plot_line(self.U_boundary_line, color='g')
            plot_line(self.D_boundary_line, color='g')
            plot_line(self.R_boundary_line, color='g')
            plot_point_set(Radon_point_set, color='r')
            plt.pause(1)
            # end = input('Press enter to the next step')

"""### main"""

# import time

# # from centerpoint.Centerpoint import *

# random.seed(1)


# def plotResult(point_set, cp):
#     plt.clf()
#     x_min, x_max = find_x_bounds(point_set)
#     interval = Interval(x_min - 10, x_max + 10)
#     y_min, y_max = find_y_bounds(point_set)
#     prepare_axis(interval.l - 5, interval.r + 5, y_min - 5, y_max + 5)
#     plot_point_set(point_set, color='b')
#     plot_point(cp, color='r')
#     plt.pause(1)
#     # end = input('Press enter to the next step.')


# if __name__ == '__main__':
#     n = 500  # total number of points
#     plot = False
#     start_time = time.time()
#     point_set = random_point_set(n, lower=-100, upper=100)
#     cp = Centerpoint(plot=plot)
#     centerpoint = cp.reduce_then_get_centerpoint(point_set)
#     #centerpoint = cp.getSafeCenterPoint(point_set)
#     print("Centerpoints: %.2f, %.2f" % (centerpoint.x, centerpoint.y))
#     print("Total time used for %d points is: %.2f s" % (n, time.time() - start_time))

#     plotResult(point_set, centerpoint)

